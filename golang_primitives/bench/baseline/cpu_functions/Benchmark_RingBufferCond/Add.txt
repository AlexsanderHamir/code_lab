Total: 52.38s
ROUTINE ======================== internal/runtime/atomic.(*Int64).Add in /opt/homebrew/Cellar/go/1.24.3/libexec/src/internal/runtime/atomic/types.go
      10ms       10ms (flat, cum) 0.019% of Total
         .          .    108:func (i *Int64) Add(delta int64) int64 {
      10ms       10ms    109:	return Xaddint64(&i.value, delta)
         .          .    110:}
         .          .    111:
         .          .    112:// Uint8 is an atomically accessed uint8 value.
         .          .    113://
         .          .    114:// A Uint8 must not be copied.
ROUTINE ======================== internal/runtime/atomic.(*Uint32).Add in /opt/homebrew/Cellar/go/1.24.3/libexec/src/internal/runtime/atomic/types.go
      50ms       50ms (flat, cum) 0.095% of Total
         .          .    290:func (u *Uint32) Add(delta int32) uint32 {
      50ms       50ms    291:	return Xadd(&u.value, delta)
         .          .    292:}
         .          .    293:
         .          .    294:// Uint64 is an atomically accessed uint64 value.
         .          .    295://
         .          .    296:// 8-byte aligned on all platforms, unlike a regular uint64.
ROUTINE ======================== runtime.(*moduledata).textAddr in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/symtab.go
      40ms       40ms (flat, cum) 0.076% of Total
         .          .    681:func (md *moduledata) textAddr(off32 uint32) uintptr {
         .          .    682:	off := uintptr(off32)
         .          .    683:	res := md.text + off
      10ms       10ms    684:	if len(md.textsectmap) > 1 {
         .          .    685:		for i, sect := range md.textsectmap {
         .          .    686:			// For the last section, include the end address (etext), as it is included in the functab.
         .          .    687:			if off >= sect.vaddr && off < sect.end || (i == len(md.textsectmap)-1 && off == sect.end) {
         .          .    688:				res = sect.baseaddr + off - sect.vaddr
         .          .    689:				break
         .          .    690:			}
         .          .    691:		}
         .          .    692:		if res > md.etext && GOARCH != "wasm" { // on wasm, functions do not live in the same address space as the linear memory
         .          .    693:			println("runtime: textAddr", hex(res), "out of range", hex(md.text), "-", hex(md.etext))
         .          .    694:			throw("runtime: text offset out of range")
         .          .    695:		}
         .          .    696:	}
      30ms       30ms    697:	return res
         .          .    698:}
         .          .    699:
         .          .    700:// textOff is the opposite of textAddr. It converts a PC to a (virtual) offset
         .          .    701:// to md.text, and returns if the PC is in any Go text section.
         .          .    702://
