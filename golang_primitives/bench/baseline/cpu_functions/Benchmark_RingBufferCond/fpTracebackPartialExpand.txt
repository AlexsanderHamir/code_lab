Total: 52.38s
ROUTINE ======================== runtime.fpTracebackPartialExpand in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/mprof.go
      20ms      440ms (flat, cum)  0.84% of Total
         .          .    578:func fpTracebackPartialExpand(skip int, fp unsafe.Pointer, pcBuf []uintptr) int {
         .          .    579:	var n int
         .          .    580:	lastFuncID := abi.FuncIDNormal
         .          .    581:	skipOrAdd := func(retPC uintptr) bool {
         .          .    582:		if skip > 0 {
         .          .    583:			skip--
         .          .    584:		} else if n < len(pcBuf) {
         .          .    585:			pcBuf[n] = retPC
         .          .    586:			n++
         .          .    587:		}
         .          .    588:		return n < len(pcBuf)
         .          .    589:	}
      10ms       10ms    590:	for n < len(pcBuf) && fp != nil {
         .          .    591:		// return addr sits one word above the frame pointer
         .          .    592:		pc := *(*uintptr)(unsafe.Pointer(uintptr(fp) + goarch.PtrSize))
         .          .    593:
         .          .    594:		if skip > 0 {
         .          .    595:			callPC := pc - 1
         .       90ms    596:			fi := findfunc(callPC)
         .      160ms    597:			u, uf := newInlineUnwinder(fi, callPC)
         .      140ms    598:			for ; uf.valid(); uf = u.next(uf) {
         .       10ms    599:				sf := u.srcFunc(uf)
         .          .    600:				if sf.funcID == abi.FuncIDWrapper && elideWrapperCalling(lastFuncID) {
         .          .    601:					// ignore wrappers
         .       20ms    602:				} else if more := skipOrAdd(uf.pc + 1); !more {
         .          .    603:					return n
         .          .    604:				}
         .          .    605:				lastFuncID = sf.funcID
         .          .    606:			}
         .          .    607:		} else {
         .          .    608:			// We've skipped the desired number of frames, so no need
         .          .    609:			// to perform further inline expansion now.
         .          .    610:			pcBuf[n] = pc
         .          .    611:			n++
         .          .    612:		}
         .          .    613:
         .          .    614:		// follow the frame pointer to the next one
      10ms       10ms    615:		fp = unsafe.Pointer(*(*uintptr)(fp))
         .          .    616:	}
         .          .    617:	return n
         .          .    618:}
         .          .    619:
         .          .    620:// lockTimer assists with profiling contention on runtime-internal locks.
ROUTINE ======================== runtime.fpTracebackPartialExpand.func1 in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/mprof.go
      20ms       20ms (flat, cum) 0.038% of Total
         .          .    581:	skipOrAdd := func(retPC uintptr) bool {
      10ms       10ms    582:		if skip > 0 {
         .          .    583:			skip--
         .          .    584:		} else if n < len(pcBuf) {
      10ms       10ms    585:			pcBuf[n] = retPC
         .          .    586:			n++
         .          .    587:		}
         .          .    588:		return n < len(pcBuf)
         .          .    589:	}
         .          .    590:	for n < len(pcBuf) && fp != nil {
