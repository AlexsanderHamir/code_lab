Total: 48.01s
ROUTINE ======================== runtime.(*timers).check in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/time.go
      20ms       30ms (flat, cum) 0.062% of Total
         .          .    952:func (ts *timers) check(now int64) (rnow, pollUntil int64, ran bool) {
         .          .    953:	ts.trace("check")
         .          .    954:	// If it's not yet time for the first timer, or the first adjusted
         .          .    955:	// timer, then there is nothing to do.
         .          .    956:	next := ts.wakeTime()
      20ms       20ms    957:	if next == 0 {
         .          .    958:		// No timers to run or adjust.
         .          .    959:		return now, 0, false
         .          .    960:	}
         .          .    961:
         .          .    962:	if now == 0 {
         .       10ms    963:		now = nanotime()
         .          .    964:	}
         .          .    965:
         .          .    966:	// If this is the local P, and there are a lot of deleted timers,
         .          .    967:	// clear them out. We only do this for the local P to reduce
         .          .    968:	// lock contention on timersLock.
ROUTINE ======================== runtime.checkRunqsNoP in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/proc.go
      20ms       30ms (flat, cum) 0.062% of Total
         .          .   3753:func checkRunqsNoP(allpSnapshot []*p, idlepMaskSnapshot pMask) *p {
      10ms       10ms   3754:	for id, p2 := range allpSnapshot {
      10ms       20ms   3755:		if !idlepMaskSnapshot.read(uint32(id)) && !runqempty(p2) {
         .          .   3756:			lock(&sched.lock)
         .          .   3757:			pp, _ := pidlegetSpinning(0)
         .          .   3758:			if pp == nil {
         .          .   3759:				// Can't get a P, don't bother checking remaining Ps.
         .          .   3760:				unlock(&sched.lock)
