Total: 48.01s
ROUTINE ======================== runtime.fpTracebackPartialExpand in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/mprof.go
      20ms      260ms (flat, cum)  0.54% of Total
         .          .    578:func fpTracebackPartialExpand(skip int, fp unsafe.Pointer, pcBuf []uintptr) int {
         .          .    579:	var n int
         .          .    580:	lastFuncID := abi.FuncIDNormal
         .          .    581:	skipOrAdd := func(retPC uintptr) bool {
         .          .    582:		if skip > 0 {
         .          .    583:			skip--
         .          .    584:		} else if n < len(pcBuf) {
         .          .    585:			pcBuf[n] = retPC
         .          .    586:			n++
         .          .    587:		}
         .          .    588:		return n < len(pcBuf)
         .          .    589:	}
         .          .    590:	for n < len(pcBuf) && fp != nil {
         .          .    591:		// return addr sits one word above the frame pointer
         .          .    592:		pc := *(*uintptr)(unsafe.Pointer(uintptr(fp) + goarch.PtrSize))
         .          .    593:
         .          .    594:		if skip > 0 {
         .          .    595:			callPC := pc - 1
         .       50ms    596:			fi := findfunc(callPC)
         .      110ms    597:			u, uf := newInlineUnwinder(fi, callPC)
      20ms       60ms    598:			for ; uf.valid(); uf = u.next(uf) {
         .          .    599:				sf := u.srcFunc(uf)
         .          .    600:				if sf.funcID == abi.FuncIDWrapper && elideWrapperCalling(lastFuncID) {
         .          .    601:					// ignore wrappers
         .       40ms    602:				} else if more := skipOrAdd(uf.pc + 1); !more {
         .          .    603:					return n
         .          .    604:				}
         .          .    605:				lastFuncID = sf.funcID
         .          .    606:			}
         .          .    607:		} else {
ROUTINE ======================== runtime.fpTracebackPartialExpand.func1 in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/mprof.go
      40ms       40ms (flat, cum) 0.083% of Total
         .          .    581:	skipOrAdd := func(retPC uintptr) bool {
      20ms       20ms    582:		if skip > 0 {
         .          .    583:			skip--
         .          .    584:		} else if n < len(pcBuf) {
      10ms       10ms    585:			pcBuf[n] = retPC
         .          .    586:			n++
         .          .    587:		}
      10ms       10ms    588:		return n < len(pcBuf)
         .          .    589:	}
         .          .    590:	for n < len(pcBuf) && fp != nil {
         .          .    591:		// return addr sits one word above the frame pointer
         .          .    592:		pc := *(*uintptr)(unsafe.Pointer(uintptr(fp) + goarch.PtrSize))
         .          .    593:
