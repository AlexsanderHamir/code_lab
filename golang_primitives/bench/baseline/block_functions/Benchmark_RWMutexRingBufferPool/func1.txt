Total: 61.50s
ROUTINE ======================== primitives_performance.Benchmark_RWMutexRingBufferPool.func1 in /Users/alexsandergomes/Documents/experiments/golang_primitives/bench_test.go
         0     33.49s (flat, cum) 54.46% of Total
         .          .     32:	b.RunParallel(func(pb *testing.PB) {
         .          .     33:		for pb.Next() {
         .     16.82s     34:			obj := pool.Get()
         .     16.67s     35:			pool.Put(obj)
         .          .     36:		}
         .          .     37:	})
         .          .     38:}
         .          .     39:
         .          .     40:// Benchmark: Channel-based pool
ROUTINE ======================== testing.(*B).RunParallel.func1 in /opt/homebrew/Cellar/go/1.24.3/libexec/src/testing/benchmark.go
         0     33.49s (flat, cum) 54.46% of Total
         .          .    955:		go func() {
         .          .    956:			defer wg.Done()
         .          .    957:			pb := &PB{
         .          .    958:				globalN: &n,
         .          .    959:				grain:   grain,
         .          .    960:				bN:      uint64(b.N),
         .          .    961:			}
         .     33.49s    962:			body(pb)
         .          .    963:		}()
         .          .    964:	}
         .          .    965:	wg.Wait()
         .          .    966:	if n.Load() <= uint64(b.N) && !b.Failed() {
         .          .    967:		b.Fatal("RunParallel: body exited without pb.Next() == false")
ROUTINE ======================== testing.(*B).run1.func1 in /opt/homebrew/Cellar/go/1.24.3/libexec/src/testing/benchmark.go
         0    13.88us (flat, cum) 2.3e-05% of Total
         .          .    238:	go func() {
         .          .    239:		// Signal that we're done whether we return normally
         .          .    240:		// or by FailNow's runtime.Goexit.
         .          .    241:		defer func() {
         .          .    242:			b.signal <- true
         .          .    243:		}()
         .          .    244:
         .    13.88us    245:		b.runN(1)
         .          .    246:	}()
         .          .    247:	<-b.signal
         .          .    248:	if b.failed {
         .          .    249:		fmt.Fprintf(b.w, "%s--- FAIL: %s\n%s", b.chatty.prefix(), b.name, b.output)
         .          .    250:		return false
ROUTINE ======================== testing.(*M).after.func1 in /opt/homebrew/Cellar/go/1.24.3/libexec/src/testing/testing.go
         0   187.83ms (flat, cum)  0.31% of Total
         .          .   2366:	m.afterOnce.Do(func() {
         .   187.83ms   2367:		m.writeProfiles()
         .          .   2368:	})
         .          .   2369:
         .          .   2370:	// Restore PanicOnExit0 after every run, because we set it to true before
         .          .   2371:	// every run. Otherwise, if m.Run is called multiple times the behavior of
         .          .   2372:	// os.Exit(0) will not be restored after the second run.
ROUTINE ======================== testing.runBenchmarks.func1 in /opt/homebrew/Cellar/go/1.24.3/libexec/src/testing/benchmark.go
         0     13.92s (flat, cum) 22.63% of Total
         .          .    706:		benchFunc: func(b *B) {
         .          .    707:			for _, Benchmark := range bs {
         .     13.92s    708:				b.Run(Benchmark.Name, Benchmark.F)
         .          .    709:			}
         .          .    710:		},
         .          .    711:		benchTime: benchTime,
         .          .    712:		bstate:    bstate,
         .          .    713:	}
