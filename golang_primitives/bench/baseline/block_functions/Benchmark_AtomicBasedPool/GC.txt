Total: 37.13s
ROUTINE ======================== runtime.GC in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/mgc.go
         0     1.71us (flat, cum) 4.6e-06% of Total
         .          .    467:func GC() {
         .          .    468:	// We consider a cycle to be: sweep termination, mark, mark
         .          .    469:	// termination, and sweep. This function shouldn't return
         .          .    470:	// until a full cycle has been completed, from beginning to
         .          .    471:	// end. Hence, we always want to finish up the current cycle
         .          .    472:	// and start a new one. That means:
         .          .    473:	//
         .          .    474:	// 1. In sweep termination, mark, or mark termination of cycle
         .          .    475:	// N, wait until mark termination N completes and transitions
         .          .    476:	// to sweep N.
         .          .    477:	//
         .          .    478:	// 2. In sweep N, help with sweep N.
         .          .    479:	//
         .          .    480:	// At this point we can begin a full cycle N+1.
         .          .    481:	//
         .          .    482:	// 3. Trigger cycle N+1 by starting sweep termination N+1.
         .          .    483:	//
         .          .    484:	// 4. Wait for mark termination N+1 to complete.
         .          .    485:	//
         .          .    486:	// 5. Help with sweep N+1 until it's done.
         .          .    487:	//
         .          .    488:	// This all has to be written to deal with the fact that the
         .          .    489:	// GC may move ahead on its own. For example, when we block
         .          .    490:	// until mark termination N, we may wake up in cycle N+2.
         .          .    491:
         .          .    492:	// Wait until the current sweep termination, mark, and mark
         .          .    493:	// termination complete.
         .          .    494:	n := work.cycles.Load()
         .          .    495:	gcWaitOnMark(n)
         .          .    496:
         .          .    497:	// We're now in sweep N or later. Trigger GC cycle N+1, which
         .          .    498:	// will first finish sweep N if necessary and then enter sweep
         .          .    499:	// termination N+1.
         .     1.71us    500:	gcStart(gcTrigger{kind: gcTriggerCycle, n: n + 1})
         .          .    501:
         .          .    502:	// Wait for mark termination N+1 to complete.
         .          .    503:	gcWaitOnMark(n + 1)
         .          .    504:
         .          .    505:	// Finish sweep N+1 before returning. We do this both to
