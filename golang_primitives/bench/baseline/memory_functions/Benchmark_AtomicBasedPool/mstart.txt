Total: 10.13MB
ROUTINE ======================== runtime.mstart in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/asm_arm64.s
         0     1.50MB (flat, cum) 14.84% of Total
         .          .    128:TEXT runtime·mstart(SB),NOSPLIT|TOPFRAME,$0
         .     1.50MB    129:	BL	runtime·mstart0(SB)
         .          .    130:	RET // not reached
         .          .    131:
         .          .    132:/*
         .          .    133: *  go-routine
         .          .    134: */
ROUTINE ======================== runtime.mstart0 in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/proc.go
         0     1.50MB (flat, cum) 14.84% of Total
         .          .   1782:func mstart0() {
         .          .   1783:	gp := getg()
         .          .   1784:
         .          .   1785:	osStack := gp.stack.lo == 0
         .          .   1786:	if osStack {
         .          .   1787:		// Initialize stack bounds from system stack.
         .          .   1788:		// Cgo may have left stack size in stack.hi.
         .          .   1789:		// minit may update the stack bounds.
         .          .   1790:		//
         .          .   1791:		// Note: these bounds may not be very accurate.
         .          .   1792:		// We set hi to &size, but there are things above
         .          .   1793:		// it. The 1024 is supposed to compensate this,
         .          .   1794:		// but is somewhat arbitrary.
         .          .   1795:		size := gp.stack.hi
         .          .   1796:		if size == 0 {
         .          .   1797:			size = 16384 * sys.StackGuardMultiplier
         .          .   1798:		}
         .          .   1799:		gp.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))
         .          .   1800:		gp.stack.lo = gp.stack.hi - size + 1024
         .          .   1801:	}
         .          .   1802:	// Initialize stack guard so that we can start calling regular
         .          .   1803:	// Go code.
         .          .   1804:	gp.stackguard0 = gp.stack.lo + stackGuard
         .          .   1805:	// This is the g0, so we can also call go:systemstack
         .          .   1806:	// functions, which check stackguard1.
         .          .   1807:	gp.stackguard1 = gp.stackguard0
         .     1.50MB   1808:	mstart1()
         .          .   1809:
         .          .   1810:	// Exit this thread.
         .          .   1811:	if mStackIsSystemAllocated() {
         .          .   1812:		// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate
         .          .   1813:		// the stack, but put it in gp.stack before mstart,
ROUTINE ======================== runtime.mstart1 in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/proc.go
         0     1.50MB (flat, cum) 14.84% of Total
         .          .   1824:func mstart1() {
         .          .   1825:	gp := getg()
         .          .   1826:
         .          .   1827:	if gp != gp.m.g0 {
         .          .   1828:		throw("bad runtime·mstart")
         .          .   1829:	}
         .          .   1830:
         .          .   1831:	// Set up m.g0.sched as a label returning to just
         .          .   1832:	// after the mstart1 call in mstart0 above, for use by goexit0 and mcall.
         .          .   1833:	// We're never coming back to mstart1 after we call schedule,
         .          .   1834:	// so other calls can reuse the current frame.
         .          .   1835:	// And goexit0 does a gogo that needs to return from mstart1
         .          .   1836:	// and let mstart0 exit the thread.
         .          .   1837:	gp.sched.g = guintptr(unsafe.Pointer(gp))
         .          .   1838:	gp.sched.pc = sys.GetCallerPC()
         .          .   1839:	gp.sched.sp = sys.GetCallerSP()
         .          .   1840:
         .          .   1841:	asminit()
         .          .   1842:	minit()
         .          .   1843:
         .          .   1844:	// Install signal handlers; after minit so that minit can
         .          .   1845:	// prepare the thread to be able to handle the signals.
         .          .   1846:	if gp.m == &m0 {
         .          .   1847:		mstartm0()
         .          .   1848:	}
         .          .   1849:
         .          .   1850:	if debug.dataindependenttiming == 1 {
         .          .   1851:		sys.EnableDIT()
         .          .   1852:	}
         .          .   1853:
         .          .   1854:	if fn := gp.m.mstartfn; fn != nil {
         .          .   1855:		fn()
         .          .   1856:	}
         .          .   1857:
         .          .   1858:	if gp.m != &m0 {
         .          .   1859:		acquirep(gp.m.nextp.ptr())
         .          .   1860:		gp.m.nextp = 0
         .          .   1861:	}
         .     1.50MB   1862:	schedule()
         .          .   1863:}
         .          .   1864:
         .          .   1865:// mstartm0 implements part of mstart1 that only runs on the m0.
         .          .   1866://
         .          .   1867:// Write barriers are allowed here because we know the GC can't be
