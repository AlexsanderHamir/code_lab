Total: 7.05MB
ROUTINE ======================== runtime.injectglist in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/proc.go
         0      513kB (flat, cum)  7.11% of Total
         .          .   3896:func injectglist(glist *gList) {
         .          .   3897:	if glist.empty() {
         .          .   3898:		return
         .          .   3899:	}
         .          .   3900:
         .          .   3901:	// Mark all the goroutines as runnable before we put them
         .          .   3902:	// on the run queues.
         .          .   3903:	head := glist.head.ptr()
         .          .   3904:	var tail *g
         .          .   3905:	qsize := 0
         .          .   3906:	trace := traceAcquire()
         .          .   3907:	for gp := head; gp != nil; gp = gp.schedlink.ptr() {
         .          .   3908:		tail = gp
         .          .   3909:		qsize++
         .          .   3910:		casgstatus(gp, _Gwaiting, _Grunnable)
         .          .   3911:		if trace.ok() {
         .          .   3912:			trace.GoUnpark(gp, 0)
         .          .   3913:		}
         .          .   3914:	}
         .          .   3915:	if trace.ok() {
         .          .   3916:		traceRelease(trace)
         .          .   3917:	}
         .          .   3918:
         .          .   3919:	// Turn the gList into a gQueue.
         .          .   3920:	var q gQueue
         .          .   3921:	q.head.set(head)
         .          .   3922:	q.tail.set(tail)
         .          .   3923:	*glist = gList{}
         .          .   3924:
         .          .   3925:	startIdle := func(n int) {
         .          .   3926:		for i := 0; i < n; i++ {
         .          .   3927:			mp := acquirem() // See comment in startm.
         .          .   3928:			lock(&sched.lock)
         .          .   3929:
         .          .   3930:			pp, _ := pidlegetSpinning(0)
         .          .   3931:			if pp == nil {
         .          .   3932:				unlock(&sched.lock)
         .          .   3933:				releasem(mp)
         .          .   3934:				break
         .          .   3935:			}
         .          .   3936:
         .          .   3937:			startm(pp, false, true)
         .          .   3938:			unlock(&sched.lock)
         .          .   3939:			releasem(mp)
         .          .   3940:		}
         .          .   3941:	}
         .          .   3942:
         .          .   3943:	pp := getg().m.p.ptr()
         .          .   3944:	if pp == nil {
         .          .   3945:		lock(&sched.lock)
         .          .   3946:		globrunqputbatch(&q, int32(qsize))
         .          .   3947:		unlock(&sched.lock)
         .      513kB   3948:		startIdle(qsize)
         .          .   3949:		return
         .          .   3950:	}
         .          .   3951:
         .          .   3952:	npidle := int(sched.npidle.Load())
         .          .   3953:	var (
ROUTINE ======================== runtime.injectglist.func1 in /opt/homebrew/Cellar/go/1.24.3/libexec/src/runtime/proc.go
         0      513kB (flat, cum)  7.11% of Total
         .          .   3925:	startIdle := func(n int) {
         .          .   3926:		for i := 0; i < n; i++ {
         .          .   3927:			mp := acquirem() // See comment in startm.
         .          .   3928:			lock(&sched.lock)
         .          .   3929:
         .          .   3930:			pp, _ := pidlegetSpinning(0)
         .          .   3931:			if pp == nil {
         .          .   3932:				unlock(&sched.lock)
         .          .   3933:				releasem(mp)
         .          .   3934:				break
         .          .   3935:			}
         .          .   3936:
         .      513kB   3937:			startm(pp, false, true)
         .          .   3938:			unlock(&sched.lock)
         .          .   3939:			releasem(mp)
         .          .   3940:		}
         .          .   3941:	}
         .          .   3942:
